package com.arhimag.games.omnomnom.Levels;

import java.util.Random;

import android.util.Log;

import com.arhimag.games.omnomnom.Food;
import com.arhimag.games.omnomnom.Snake;
import com.arhimag.games.omnomnom.Maps.GameMap;
import com.arhimag.games.omnomnom.framework.Point;

public abstract class GameLevel
{
	protected GameMap map;
	protected Snake snake;
	protected Food[] food; 
	protected float ticksEverySecs = 0.5f;
	protected float timeShift = 0.075f;
	protected float speedupCount = 3;
	protected float timeFromTick;
	protected Point finishes[];
	protected boolean nextLevel = false;
	protected int winLength = 5;
	protected boolean moved;
	protected boolean eat = false;
	protected Point teleports[];  
	
	protected boolean ticked = true;
	
	public GameLevel( GameMap map )
	{
		this.map = map;
		food = new Food[0];
		finishes = new Point[0];
		teleports = new Point[0];
	}
	
	public GameMap getMap()
	{
		return map;
	}
	
	public Snake getSnake()
	{
		return snake;
	}
	
	public void goUP()
	{
		if( snake.direction != Snake.DOWN &&  snake.direction != Snake.UP )
		{
			if( ticked )
				snake.direction = Snake.UP;
			ticked = false;
		}
	}
	
	public void goDOWN()
	{
		if( snake.direction != Snake.UP &&  snake.direction != Snake.DOWN )
		{
			if( ticked )
				snake.direction = Snake.DOWN;
			ticked = false;
		}
	}
	
	public void goRIGHT()
	{
		if( snake.direction != Snake.LEFT &&  snake.direction != Snake.RIGHT )
		{
			if( ticked )
				snake.direction = Snake.RIGHT;
			ticked = false;
		}
	}
	
	public void goLEFT()
	{
		if( snake.direction != Snake.RIGHT &&  snake.direction != Snake.LEFT )
		{
			if( ticked )
				snake.direction = Snake.LEFT;
			ticked = false;
		}
	}
	
	public void turnLeft()
	{
		if( ticked )
			snake.turnLeft();
		ticked = false;
	}
	
	public void turnRight()
	{
		if( ticked )
			snake.turnRight();
		ticked = false;
	}

	protected void generateNewFood( int i )
	{
		Random rand = new Random();
		int x = rand.nextInt(this.map.getMapWidth());
		int y = rand.nextInt(this.map.getMapHeight());
		while( this.map.getFlatMap(x,y) != ' ' )
		{
			x = rand.nextInt(this.map.getMapWidth());
			y = rand.nextInt(this.map.getMapHeight());
		}
		this.food[i].x = x;
		this.food[i].y = y;
	}
	
	public void update(float deltaTime )
	{
		eat = false;
		timeFromTick += deltaTime;
		if (timeFromTick > this.getTickTime())
		{
			tick();
			timeFromTick = 0.0f;
		}
	}
	
	public void tick()
	{
		int nextFieldX = -1;
		int nextFieldY = -1;
		char nextFieldValue;
		boolean tail;
		
		if( snake.direction ==  Snake.UP)
		{
			nextFieldX = snake.parts.get(0).x;
			nextFieldY = snake.parts.get(0).y - 1;
		} 
		else if( snake.direction == Snake.DOWN )
		{
			nextFieldX = snake.parts.get(0).x;
			nextFieldY = snake.parts.get(0).y + 1;
		} 
		else if( snake.direction == Snake.LEFT )
		{
			nextFieldX = snake.parts.get(0).x - 1;
			nextFieldY = snake.parts.get(0).y ;
		} 
		else if( snake.direction == Snake.RIGHT )
		{
			nextFieldX = snake.parts.get(0).x + 1;
			nextFieldY = snake.parts.get(0).y;
		}		
		
		if( ( nextFieldX < 0 ) || 
			( nextFieldX >= map.getMapWidth() ) ||
			( nextFieldY < 0 ) ||
			( nextFieldY >= map.getMapHeight() ) )
			{
				Log.d("SnakeJourney", "Incorrect snake position!");
				throw new RuntimeException();
			}
		
		nextFieldValue = map.getFlatMap(nextFieldX,nextFieldY);
		
		boolean finish = false;
		
		if( snake.parts.size() > winLength )
			for( int i = 0; i < finishes.length; i++)
				if(( finishes[i].x == nextFieldX ) && ( finishes[i].y == nextFieldY ))
					finish = true;
		
		int teleportId = -1;
		for( int i = 0; i < teleports.length; i++ )
			if((teleports[i].x == nextFieldX ) && (teleports[i].y == nextFieldY))
				teleportId = i;
		
		if( finish )
		{
			snake.advance();
			this.nextLevel = true;
			moved = true;
		}
		else if ( teleportId >= 0)
		{
			snake.advance();
			snake.parts.get(0).x = teleports[(teleportId + 1) % teleports.length].x;
			snake.parts.get(0).y = teleports[(teleportId + 1) % teleports.length].y;
		}
		else
		{
			if( nextFieldValue != ' ' )
			{
				if( snake.parts.size() > 1)
				{
					snake.lastx = snake.parts.get(snake.parts.size() - 1).x;
					snake.lasty = snake.parts.get(snake.parts.size() - 1).y;
					snake.parts.remove(snake.parts.size() - 1);
				}
				moved = false;
			}
			else
			{
				tail = false;
				for( int i = 0; i < this.snake.parts.size(); i++)
					if ( ( nextFieldX == snake.parts.get(i).x ) && ( nextFieldY == snake.parts.get(i).y ) )
						tail = true;
				if( tail )
				{
					if( snake.parts.size() > 1)
					{
						snake.lastx = snake.parts.get(snake.parts.size() - 1).x;
						snake.lasty = snake.parts.get(snake.parts.size() - 1).y;
						snake.parts.remove(snake.parts.size() - 1);
					}
					moved = false;
				}
				else
				{
					for( int i = 0; i < food.length; i++)
					{
						if (( nextFieldX == food[i].x ) && ( nextFieldY == food[i].y ))
						{
							this.snake.eat();
							eat = true;
							this.generateNewFood(i);
							break;
						}
					}
					snake.advance();
					moved = true;
				}
			}
		}
			
		ticked = true;
	}
	
	public float getTickTime()
	{
		return ticksEverySecs - timeShift * (this.snake.parts.size() / this.speedupCount) ;
	}
	
	public float getTicks()
	{
		return timeFromTick;
	}
	
	public boolean getMoved()
	{
		return moved;
	}
	
	public Food getFood(int i)
	{
		return food[i];
	}
	
	public int getFoodLength()
	{
		if( food != null )
			return food.length;
		else
			return 0;
	}
	
	public boolean nextLevel()
	{
		return nextLevel;
	}
	
	public int getFinishesCount()
	{
		if( this.snake.parts.size() > winLength )
			if( finishes != null )
				return finishes.length;
			else
				return 0;
		else
			return 0;
	}
	
	public int getFinishX(int i)
	{
		return finishes[i].x;
	}
	
	public int getFinishY(int i)
	{
		return finishes[i].y;
	}
	
	public int getTeleportesCount()
	{
		if( teleports != null )
			return teleports.length;
		else
			return 0;
	}
	
	public int getTeleportX(int i)
	{
		return teleports[i].x;
	}
	
	public int getTeleportY(int i)
	{
		return teleports[i].y;
	}
	
	
	public boolean getEat()
	{
		return eat;
	}

}
