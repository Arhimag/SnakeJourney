package com.arhimag.games.omnomnom.Levels;

import java.util.Random;

import android.util.Log;

import com.arhimag.games.omnomnom.Food;
import com.arhimag.games.omnomnom.Snake;
import com.arhimag.games.omnomnom.Maps.GameMap;

public abstract class GameLevel
{
	protected GameMap map;
	protected Snake snake;
	protected Food[] food; 
	protected float ticksEverySecs = 0.5f;
	protected float timeShift = 0.075f;
	protected float speedupCount = 3;
	protected float timeFromTick;
	protected int finishX[];
	protected int finishY[];
	protected boolean nextLevel = false;
	protected int winLength = 5;
	protected boolean moved;
	protected boolean eat = false;
	
	protected boolean ticked = true;
	
	public GameLevel( GameMap map )
	{
		this.map = map;
		food = new Food[0];
		finishX = new int[0];
		finishY = new int[0];
	}
	
	public GameMap getMap()
	{
		return map;
	}
	
	public Snake getSnake()
	{
		return snake;
	}
	
	public void goUP()
	{
		if( snake.direction != Snake.DOWN &&  snake.direction != Snake.UP )
		{
			if( ticked )
				snake.direction = Snake.UP;
			ticked = false;
		}
	}
	
	public void goDOWN()
	{
		if( snake.direction != Snake.UP &&  snake.direction != Snake.DOWN )
		{
			if( ticked )
				snake.direction = Snake.DOWN;
			ticked = false;
		}
	}
	
	public void goRIGHT()
	{
		if( snake.direction != Snake.LEFT &&  snake.direction != Snake.RIGHT )
		{
			if( ticked )
				snake.direction = Snake.RIGHT;
			ticked = false;
		}
	}
	
	public void goLEFT()
	{
		if( snake.direction != Snake.RIGHT &&  snake.direction != Snake.LEFT )
		{
			if( ticked )
				snake.direction = Snake.LEFT;
			ticked = false;
		}
	}
	
	public void turnLeft()
	{
		if( ticked )
			snake.turnLeft();
		ticked = false;
	}
	
	public void turnRight()
	{
		if( ticked )
			snake.turnRight();
		ticked = false;
	}

	protected void generateNewFood( int i )
	{
		Random rand = new Random();
		int x = rand.nextInt(this.map.getMapWidth());
		int y = rand.nextInt(this.map.getMapHeight());
		while( this.map.getFlatMap(x,y) != ' ' )
		{
			x = rand.nextInt(this.map.getMapWidth());
			y = rand.nextInt(this.map.getMapHeight());
		}
		this.food[i].x = x;
		this.food[i].y = y;
	}
	
	public void update(float deltaTime )
	{
		eat = false;
		timeFromTick += deltaTime;
		if (timeFromTick > this.getTickTime())
		{
			tick();
			timeFromTick = 0.0f;
		}
	}
	
	public void tick()
	{
		int nextFieldX = -1;
		int nextFieldY = -1;
		char nextFieldValue;
		boolean tail;
		
		if( snake.direction ==  Snake.UP)
		{
			nextFieldX = snake.parts.get(0).x;
			nextFieldY = snake.parts.get(0).y - 1;
		} 
		else if( snake.direction == Snake.DOWN )
		{
			nextFieldX = snake.parts.get(0).x;
			nextFieldY = snake.parts.get(0).y + 1;
		} 
		else if( snake.direction == Snake.LEFT )
		{
			nextFieldX = snake.parts.get(0).x - 1;
			nextFieldY = snake.parts.get(0).y ;
		} 
		else if( snake.direction == Snake.RIGHT )
		{
			nextFieldX = snake.parts.get(0).x + 1;
			nextFieldY = snake.parts.get(0).y;
		}		
		
		if( ( nextFieldX < 0 ) || 
			( nextFieldX >= map.getMapWidth() ) ||
			( nextFieldY < 0 ) ||
			( nextFieldY >= map.getMapHeight() ) )
			{
				Log.d("SnakeJourney", "Incorrect snake position!");
				throw new RuntimeException();
			}
		
		nextFieldValue = map.getFlatMap(nextFieldX,nextFieldY);
		
		if( nextFieldValue != ' ' )
		{
			boolean finish = false;
			
			if( snake.parts.size() > winLength )
				for( int i = 0; i < finishX.length; i++)
					if(( finishX[i] == nextFieldX ) && ( finishY[i] == nextFieldY ))
						finish = true;
			
			if( finish )
			{
				snake.advance();
				this.nextLevel = true;
				moved = true;
			}
			else
			{
				if( snake.parts.size() > 1)
				{
					snake.lastx = snake.parts.get(snake.parts.size() - 1).x;
					snake.lasty = snake.parts.get(snake.parts.size() - 1).y;
					snake.parts.remove(snake.parts.size() - 1);
				}
				moved = false;
			}
		}
		else
		{
			tail = false;
			for( int i = 0; i < this.snake.parts.size(); i++)
				if ( ( nextFieldX == snake.parts.get(i).x ) && ( nextFieldY == snake.parts.get(i).y ) )
					tail = true;
			if( tail )
			{
				if( snake.parts.size() > 1)
				{
					snake.lastx = snake.parts.get(snake.parts.size() - 1).x;
					snake.lasty = snake.parts.get(snake.parts.size() - 1).y;
					snake.parts.remove(snake.parts.size() - 1);
				}
				moved = false;
			}
			else
			{
				for( int i = 0; i < food.length; i++)
				{
					if (( nextFieldX == food[i].x ) && ( nextFieldY == food[i].y ))
					{
						this.snake.eat();
						eat = true;
						this.generateNewFood(i);
						break;
					}
				}
				snake.advance();
				moved = true;
			}
		}
		
			
		ticked = true;
	}
	
	public float getTickTime()
	{
		return ticksEverySecs - timeShift * (this.snake.parts.size() / this.speedupCount) ;
	}
	
	public float getTicks()
	{
		return timeFromTick;
	}
	
	public boolean getMoved()
	{
		return moved;
	}
	
	public Food getFood(int i)
	{
		return food[i];
	}
	
	public int getFoodLength()
	{
		if( food != null )
			return food.length;
		else
			return 0;
	}
	
	public boolean nextLevel()
	{
		return nextLevel;
	}
	
	public int getFinishesCount()
	{
		if( this.snake.parts.size() > winLength )
			if( finishX != null )
				return finishX.length;
			else
				return 0;
		else
			return 0;
	}
	
	public int getFinishX(int i)
	{
		return finishX[i];
	}
	
	public int getFinishY(int i)
	{
		return finishY[i];
	}
	
	public boolean getEat()
	{
		return eat;
	}

}
