package com.arhimag.games.omnomnom.Levels;

import java.util.Random;

import android.util.Log;

import com.arhimag.games.omnomnom.Food;
import com.arhimag.games.omnomnom.Snake;
import com.arhimag.games.omnomnom.Maps.GameMap;
import com.arhimag.games.omnomnom.framework.Point;

public abstract class GameLevel
{
	protected GameMap map;
	//protected Snake snake;
	protected Snake[] snakes;
	protected Food[] food; 
	protected boolean aqua = false;
	protected boolean pauseButton = false;
	protected float ticksEverySecs = 0.2f;
	protected float timeShift = 0.075f;
	protected float speedupCount = 3;
	protected float timeFromTick;
	protected Point finishes[];
	protected boolean nextLevel = false;
	protected int winLength = 5;
	protected boolean moved[];
	protected boolean eat = false;
	protected Point teleports[];  
	protected int playerSnake = 0;
	protected boolean gameOver = false;
	protected char[][] tempMap;
	protected boolean tempMapBuild;
	
	protected boolean readyScreen = true;
	protected int readyTicksLeft = 5;
	
	protected boolean pause = false;
	
	protected boolean ticked = true;
	protected boolean botMoved = false;
	
	//Минимзируем работу сборщика мусора
	private int i_getTickTime;
	private float minTickTime;
	private float tmp_getTickTime;
	
	public GameLevel( GameMap map )
	{
		this.map = map;
		this.snakes = new Snake[0];
		moved = new boolean[0];
		food = new Food[0];
		finishes = new Point[0];
		teleports = new Point[0];
		tempMap = new char[map.getMapWidth()][map.getMapHeight()];
		tempMapBuild = false;
		buildTempMap();
	}
	
	public int getMapVertexId(int x, int y)
	{
		return y * map.getMapWidth() + x;
	}
	
	public int getMapVertexX( int v )
	{
		return v % map.getMapWidth();
	}
	
	public int getMapVertexY( int v )
	{
		return v / map.getMapWidth();
	}

	protected void buildTempMap()
	{
		for(int x = 0; x < map.getMapWidth(); x++)
			for(int y = 0; y < map.getMapHeight(); y++)
				tempMap[x][y] = map.getFlatMap(x, y);
		for(int j = 0; j < this.snakes.length; j++)
		{
			if(snakes[j] != null)
				for(int i = 0; i < snakes[j].parts.size(); i++)
					tempMap[snakes[j].parts.get(i).x][snakes[j].parts.get(i).y] = 'S';
		}
		if( teleports != null)
			for(int i = 0; i < teleports.length; i++  )
				tempMap[teleports[i].x][teleports[i].y] = 'T';
		
		tempMapBuild = true;
	}
	
	// Возвращает iтого соседа вершины v. Если соседа такого нет, то возвращает -1 
	public int getMapGraphNeighbours( int v, int i  )
	{
		int counter = -1;
		int x = getMapVertexX(v);
		int y = getMapVertexY(v);
		
		if( x > 0 )
		{
			counter++;
			if( counter == i )
				return getMapVertexId(x - 1, y);
		}
		if( y > 0 )
		{
			counter++;
			if( counter == i )
				return getMapVertexId(x, y - 1);
		}
		if( x < map.getMapWidth() - 1 )
		{
			counter++;
			if( counter == i )
				return getMapVertexId(x + 1, y);
		}
		if( y < map.getMapHeight() - 1 )
		{
			counter++;
			if( counter == i )
				return getMapVertexId(x, y + 1);
		}
		if( tempMap[x][y] == 'T')
			for( int j = 0; j < teleports.length; j++ )
				if ( (teleports[j].x == x ) && (teleports[j].y == y) )
				{
					counter++;
					if( counter == i )
						return getMapVertexId(teleports[(j + 1) % teleports.length].x, teleports[(j + 1)%teleports.length].y );
				}
		return -1;
	}
	
	//Функция возвращает вес ребра графа-карты
	//Если вес равен -1, то он равен бесконечности
	public int getMapGraphWeight(int u, int v)
	{
		int x1, y1;
		int x2, y2;
		
		x1 = getMapVertexX(u);
		y1 = getMapVertexY(u);
		
		x2 = getMapVertexX(v);
		y2 = getMapVertexY(v);
		
		if( u >= map.getMapWidth() * map.getMapHeight() || v >= map.getMapWidth() * map.getMapHeight() )
		{
			Log.d("SnakeJourney","Incorrect value of vertexes " + u + " " + v);
			throw new RuntimeException();
		}
		
		if(( tempMap[x2][y2]!=' ') && (tempMap[x2][y2]!='T'))
			return -1;
		
		if( ( Math.abs(x1 - x2) > 1) || (Math.abs(y1 - y2) > 1) )
			return -1;
		
		if ( (tempMap[x1][y1] == 'T') && (tempMap[x2][y2] == 'T')) 
			for( int i = 0; i < teleports.length; i++ )
				if ( ( (teleports[i].x == x1 ) && (teleports[i].y == y1) && (teleports[(i + 1) % teleports.length].x == x2 ) && (teleports[(i + 1)%teleports.length].y == y2) ) ||
						( (teleports[i].x == x2 ) && (teleports[i].y == y2) && (teleports[(i + 1) % teleports.length].x == x1 ) && (teleports[(i + 1)%teleports.length].y == y1) ) )
					return 0;
		return 1;
	}
	

	public int getMapGraphWeightFinish(int u, int v)
	{
		int x1, y1;
		int x2, y2;
		
		x1 = getMapVertexX(u);
		y1 = getMapVertexY(u);
		
		x2 = getMapVertexX(v);
		y2 = getMapVertexY(v);
		
		if( u >= map.getMapWidth() * map.getMapHeight() || v >= map.getMapWidth() * map.getMapHeight() )
		{
			Log.d("SnakeJourney","Incorrect value of vertexes " + u + " " + v);
			throw new RuntimeException();
		}
		
				
		
		if ( (tempMap[x1][y1] == 'T') && (tempMap[x2][y2] == 'T')) 
			for( int i = 0; i < teleports.length; i++ )
				if ( ( (teleports[i].x == x1 ) && (teleports[i].y == y1) && (teleports[(i + 1) % teleports.length].x == x2 ) && (teleports[(i + 1)%teleports.length].y == y2) ) ||
						( (teleports[i].x == x2 ) && (teleports[i].y == y2) && (teleports[(i + 1) % teleports.length].x == x1 ) && (teleports[(i + 1)%teleports.length].y == y1) ) )
					return 0;
		
		if( ( Math.abs(x1 - x2) > 1) || (Math.abs(y1 - y2) > 1) )
			return -1;
		
		for( int i = 0; i < finishes.length; i++ )
			if ( ( x2 == finishes[i].x ) && ( y2 == finishes[i].y ) ) 
				return 1;
		
		if(( tempMap[x2][y2]!=' ') && (tempMap[x2][y2]!='T'))
			return -1;

		return 1;
	}
	
	public GameMap getMap()
	{
		return map;
	}
	
	public Snake getSnake( int i )
	{
		return snakes[i];
	}
	
	public void goUP( int i )
	{
		if( snakes[i].parts.size() == 1 || snakes[i].parts.get(1).y != snakes[i].parts.get(0).y - 1 )
		{
			if( ticked )
				snakes[i].direction = Snake.UP;
			ticked = false;
		}
	}
	
	public void goDOWN( int i )
	{
		if( snakes[i].parts.size() == 1 || snakes[i].parts.get(1).y != snakes[i].parts.get(0).y + 1 )
		{
			if( ticked )
				snakes[i].direction = Snake.DOWN;
			ticked = false;
		}
	}
	
	public void goRIGHT( int i )
	{
		if( snakes[i].parts.size() == 1 || snakes[i].parts.get(1).x != snakes[i].parts.get(0).x + 1 )
		{
			if( ticked )
				snakes[i].direction = Snake.RIGHT;
			ticked = false;
		}
	}
	
	public void goLEFT( int i )
	{
		if( snakes[i].parts.size() == 1 || snakes[i].parts.get(1).x != snakes[i].parts.get(0).x - 1 )
		{
			if( ticked )
				snakes[i].direction = Snake.LEFT;
			ticked = false;
		}
	}
	
	public void turnLeft( int i )
	{
		if( ticked )
			snakes[i].turnLeft();
		ticked = false;
	}
	
	public void turnRight( int i )
	{
		if( ticked )
			snakes[i].turnRight();
		ticked = false;
	}

	protected void generateNewFood( int i )
	{
		Random rand = new Random();
		int x = rand.nextInt(this.map.getMapWidth());
		int y = rand.nextInt(this.map.getMapHeight());
		while( this.map.getFlatMap(x,y) != ' ' )
		{
			x = rand.nextInt(this.map.getMapWidth());
			y = rand.nextInt(this.map.getMapHeight());
		}
		this.food[i].x = x;
		this.food[i].y = y;
	}
	
	public void update(float deltaTime, int snake_id )
	{
		
		
		eat = false;
		timeFromTick += deltaTime;
		
		if (timeFromTick > this.getTickTime())
		{
			if( readyScreen )
			{
				if( readyTicksLeft == 0 )
					readyScreen = false;
				else
					readyTicksLeft --;
			}
			else
			{
				tick();
			}
			timeFromTick = 0.0f;
		}
	}
	
	public void tick()
	{
		int nextFieldX = -1;
		int nextFieldY = -1;
		char nextFieldValue;
		boolean tail;
		
		if( moved.length < snakes.length )
			moved = new boolean[snakes.length];
		for(int i = 0; i < moved.length; i++)
			moved[i] = true;
		
		for( int snakeid = 0; snakeid < this.snakes.length; snakeid++ )
		{
			if( snakes[snakeid].direction ==  Snake.UP)
			{
				nextFieldX = snakes[snakeid].parts.get(0).x;
				nextFieldY = snakes[snakeid].parts.get(0).y - 1;
			} 
			else if( snakes[snakeid].direction == Snake.DOWN )
			{
				nextFieldX = snakes[snakeid].parts.get(0).x;
				nextFieldY = snakes[snakeid].parts.get(0).y + 1;
			} 
			else if( snakes[snakeid].direction == Snake.LEFT )
			{
				nextFieldX = snakes[snakeid].parts.get(0).x - 1;
				nextFieldY = snakes[snakeid].parts.get(0).y ;
			} 
			else if( snakes[snakeid].direction == Snake.RIGHT )
			{
				nextFieldX = snakes[snakeid].parts.get(0).x + 1;
				nextFieldY = snakes[snakeid].parts.get(0).y;
			}		
			
			if( ( nextFieldX < 0 ) || 
				( nextFieldX >= map.getMapWidth() ) ||
				( nextFieldY < 0 ) ||
				( nextFieldY >= map.getMapHeight() ) )
				{
					Log.d("SnakeJourney", "Incorrect snake position!");
					throw new RuntimeException();
				}
			
			nextFieldValue = map.getFlatMap(nextFieldX,nextFieldY);
			
			boolean finish = false;
			
			// Проверяем  не финишировала ли змейка
			if( snakes[snakeid].parts.size() > snakes[snakeid].finishSize )
				for( int i = 0; i < finishes.length; i++)
					if(( finishes[i].x == nextFieldX ) && ( finishes[i].y == nextFieldY ))
						finish = true;
			
			// Проверяем не пришла ли змейка в телепорт
			int teleportId = -1;
			for( int i = 0; i < teleports.length; i++ )
				if((teleports[i].x == nextFieldX ) && (teleports[i].y == nextFieldY))
					teleportId = i;
			
			// Если змейка финишировала
			if( finish )
			{
				snakes[snakeid].advance();
				if( snakeid == this.playerSnake)
					this.nextLevel = true;
				else
					this.raiseGameOver();
				moved[snakeid] = true;
			}
			// Если змейка в телепорт вошла
			else if ( teleportId >= 0)
			{
				snakes[snakeid].advance();
				snakes[snakeid].parts.get(0).x = teleports[(teleportId + 1) % teleports.length].x;
				snakes[snakeid].parts.get(0).y = teleports[(teleportId + 1) % teleports.length].y;
			}
			else
			{
				// Если змейка идет в стену
				if( nextFieldValue != ' ' )
				{
					if( snakes[snakeid].parts.size() > 1)
					{
						snakes[snakeid].lastx = snakes[snakeid].parts.get(snakes[snakeid].parts.size() - 1).x;
						snakes[snakeid].lasty = snakes[snakeid].parts.get(snakes[snakeid].parts.size() - 1).y;
						snakes[snakeid].parts.remove(snakes[snakeid].parts.size() - 1);
					}
					moved[snakeid] = false;
				}
				else
				{

					// Проверяем не произошло ли столкновение со змеями
					tail = false;
					for( int check_snake = 0; check_snake < snakes.length; check_snake++)
						for( int check_snake_id = 0; check_snake_id < snakes[check_snake].parts.size(); check_snake_id++ )
							if ( ( nextFieldX == snakes[check_snake].parts.get(check_snake_id).x ) && ( nextFieldY == snakes[check_snake].parts.get(check_snake_id).y ) )
								tail = true;

					if( tail )
					{
						if( snakes[snakeid].parts.size() > 1)
						{
							snakes[snakeid].lastx = snakes[snakeid].parts.get(snakes[snakeid].parts.size() - 1).x;
							snakes[snakeid].lasty = snakes[snakeid].parts.get(snakes[snakeid].parts.size() - 1).y;
							snakes[snakeid].parts.remove(snakes[snakeid].parts.size() - 1);
						}
						moved[snakeid] = false;
					}
					else
					{
						for( int i = 0; i < food.length; i++)
						{
							if (( nextFieldX == food[i].x ) && ( nextFieldY == food[i].y ))
							{
								this.snakes[snakeid].eat();
								eat = true;
								this.generateNewFood(i);
								break;
							}
						}
						snakes[snakeid].advance();
						moved[snakeid] = true;
					}
				}
			}
		}
		
		tempMapBuild = false;
		buildTempMap();
		ticked = true;
		botMoved = false;
	}
	
	public float getTickTime()
	{
		minTickTime = ticksEverySecs;
		for( i_getTickTime = 0; i_getTickTime < this.snakes.length; i_getTickTime++)
		{
			tmp_getTickTime = ticksEverySecs - 0.003f * this.snakes[i_getTickTime].parts.size();
			if( tmp_getTickTime < minTickTime )
				minTickTime = tmp_getTickTime;
		}
		return minTickTime;
	}
	
	public float getTicks()
	{
		return timeFromTick;
	}
	
	public boolean getMoved(int snakeid)
	{
		return moved[snakeid];
	}
	
	public Food getFood(int i)
	{
		return food[i];
	}
	
	public int getFoodLength()
	{
		if( food != null )
			return food.length;
		else
			return 0;
	}
	
	public boolean nextLevel()
	{
		return nextLevel;
	}
	
	public int getFinishesCount( int snake_id )
	{
		if (( snake_id >= 0 ) && ( this.snakes[snake_id].parts.size() > this.snakes[snake_id].finishSize ))
			if( finishes != null )
				return finishes.length;
			else
				return 0;
		else
			return 0;
	}
	
	public int getFinishX(int i)
	{
		return finishes[i].x;
	}
	
	public int getFinishY(int i)
	{
		return finishes[i].y;
	}
	
	public int getTeleportesCount()
	{
		if( teleports != null )
			return teleports.length;
		else
			return 0;
	}
	
	public int getTeleportX(int i)
	{
		return teleports[i].x;
	}
	
	public int getTeleportY(int i)
	{
		return teleports[i].y;
	}
	
	public boolean getEat()
	{
		return eat;
	}
	
	public int getPlayerSnake()
	{
		return this.playerSnake;
	}
	
	public int getSnakesCount()
	{
		return this.snakes.length;
	}
	
	public boolean getGameOver()
	{
		return gameOver;
	}
	
	public void raiseGameOver()
	{
		gameOver = true;
	}
	
	public boolean getAqua()
	{
		return aqua;
	}
	
	public void setAqua(boolean t )
	{
		aqua = t;
	}
	
	public boolean getPauseButton()
	{
		return pauseButton;
	}
	
	public void setPauseButton(boolean t )
	{
		pauseButton = t;
	}
	
	public int getFinishesLength()
	{
		return finishes.length;
	}

	public boolean isReadyScreen()
	{
		return readyScreen;
	}
	
	public int getReadyTicks()
	{
		return readyTicksLeft;
	}

}
