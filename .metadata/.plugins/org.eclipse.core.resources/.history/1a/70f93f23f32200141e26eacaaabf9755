package com.arhimag.games.omnomnom.AI;

import java.util.LinkedList;
import java.util.Queue;

import com.arhimag.games.omnomnom.Snake;
import com.arhimag.games.omnomnom.Levels.GameLevel;

public class BFSAISnake extends Snake 
{
	GameLevel level;
	private int primeNumber; // Персональное простое число присвоенное змейке, для заполнения временной карты во время прохождения BFS
	private int mapWidth;
	private int mapHeight;
	
	private int queque[]; //массив содржащий элементы очереди
	private int quequeParents[]; //массив родителей соответствующих элементов
	private int quequeStart; //индекс первого элемента
	private int quequeEnd; //индекс куда записывать новый элемент
	private int quequeSize;//размер массива
	private final int rndSequence[] = {0,1,3,2,3,2,0,1}; //Случайная последовательность поворотов
	private int rndPointer = 3;

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 *                                                             *  
	 * Эмулирование очереди массивом.                              *
	 * queque - массив содржащий элементы очереди.                 *
	 * quequeParent - массив родителей соответствующих элементов.  *
	 * quequeStart - индекс первого элемента                       *  
	 * quequeEnd - индекс куда записывать новый элемент            *
	 * quequeSize - размер массива. он не постоянен. В случае      * 
	 * нехватки места происходит удвоение размера массива с        * 
	 * копированием элементов старого, что может притормозить      * 
	 * время работы программы, поэтому имеет смысл подобрать       *
	 * оптимальный размер начального массива, чтобы оно не брало   *
	 * много памяти, но и хватало этого в 90% случаев.             *
	 *                                                             *
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
	
	/* Инициализация очереди. 
	 * Запускать только в конструкторе и только после того, как будут
	 * заданы размеры карты. В переменных mapWidth*mapHeight 
	 */
	private void initQueque()
	{
		quequeSize = mapWidth*mapHeight / 4;
		queque = new int[quequeSize];
		quequeParents = new int[quequeSize];
		quequeStart = 0;
		quequeEnd = 0;
	}
	
	/* Добавлеят элемент в коней очереди
	 * ! При нехватке места размер массива удваивается !
	 */
	private void pushQueque(int vertex, int parent )
	{
		if( quequeEnd == quequeSize )
		{
			int temp[];
			
			temp = new int[quequeSize * 2];
			java.lang.System.arraycopy(queque, 0, temp, 0, quequeSize);
			queque = temp;
			temp = null;
			
			temp = new int[quequeSize * 2];
			java.lang.System.arraycopy(quequeParents, 0, temp, 0, quequeSize);
			quequeParents = temp;
			temp = null;
			
			quequeSize *= 2;
		}
		
		queque[quequeEnd] = vertex;
		quequeParents[quequeEnd] = parent;
		quequeEnd++;		
	}
	
	/* Выдает значение первого элемента очереди. Без удаления.
	 */
	private int getQueque()
	{
		return queque[quequeStart];
	}
	
	/* Выдает родителя первого элемента очереди. Без удаления.
	 */
	private int getParentQueque()
	{
		return quequeParents[quequeStart];
	}
	
	/* Пуста ли очередь?
	 */
	private boolean isEmptyQueque()
	{
		return quequeStart < quequeEnd;
	}
	
	/* Выдает первый элемент очереди удаляя его.
	 */
	private int popQueque()
	{
		return queque[quequeStart++];
	}

	/* Очищаем очередь
	 */
	private void clearQueque()
	{
		quequeStart = 0;
		quequeEnd = 0;
	}

	/* * * * * * * * * * * * * *
	 * Конец эмуляции очереди  *
	 * * * * * * * * * * * * * */
	
	public BFSAISnake(GameLevel level, int x, int y, int primeNmbr)
	{
		super(x,y);
		this.level = level;
		primeNumber = primeNmbr;
		mapWidth = level.getMap().getMapWidth();
		mapHeight = level.getMap().getMapHeight();
		initQueque();
	}
	
	

	/* 
	 * Алгоритм работы:
	 * Ищем точку, к которой будет стремиться змейка.
	 * Начинаем поиск в ширину с найденной точки до тех пор, пока не дойдем до головы змейки.
	 * у каждой клетки храним ее родителя. Следующая клетка - это клетка родитель.
	 */
	public int getSnakeTarget()
	{
		int minWayLengthSquare = mapWidth*mapWidth + mapHeight*mapHeight;
		int target = -1;
		if( parts.size() > finishSize )
		{
			 for( int i = 0; i < level.getFinishesLength(); i++ )
				 if( (parts.get(0).x - level.getFinishX(i))*(parts.get(0).x - level.getFinishX(i)) + (parts.get(0).y -level.getFinishY(i))*(parts.get(0).y - level.getFinishY(i)) < minWayLengthSquare )
				 {
					 target = level.getMapVertexId(level.getFinishX(i), level.getFinishY(i));
					 minWayLengthSquare = (parts.get(0).x - level.getFinishX(i))*(parts.get(0).x - level.getFinishX(i)) + (parts.get(0).y -level.getFinishY(i))*(parts.get(0).y - level.getFinishY(i));
				 }
			 return target;
		}
		else
		{
			for( int i = 0; i < level.getFoodLength(); i++ )
				 if((parts.get(0).x - level.getFood(i).x)*(parts.get(0).x - level.getFood(i).x) + (parts.get(0).y - level.getFood(i).y)*(parts.get(0).y - level.getFood(i).y) < minWayLengthSquare )
				 {
					 target = level.getMapVertexId(level.getFood(i).x, level.getFood(i).y);
					 minWayLengthSquare = (parts.get(0).x - level.getFood(i).x)*(parts.get(0).x - level.getFood(i).x) + (parts.get(0).y - level.getFood(i).y)*(parts.get(0).y - level.getFood(i).y);
				 }
			return target;
		}
	}
	
	/* Если БФС не сработал и пути к выбранной точке нет, то мы выбираем 
	 * куда двигаться случайно с помощью этой функции. Преимущесственно
	 * Стараемся выбирать направления в которых не произойдет столкновений. 
	 */
	public int getRandomDirection()
	{
		int rndNumber = rndSequence[rndPointer++];
		int previousLoop = -1;
		while( rndNumber != previousLoop)
		{
			previousLoop = rndNumber;
			if ( level.getIntTempMap(level.getMapVertexId(parts.get(0).x + 1, parts.get(0).y) ) < 0 && level.getIntTempMap(level.getMapVertexId(parts.get(0).x + 1, parts.get(0).y) ) != GameLevel.TELEPORT )
				if( rndNumber-- == 0)
					return Snake.RIGHT;
			if ( level.getIntTempMap(level.getMapVertexId(parts.get(0).x - 1, parts.get(0).y) ) < 0 && level.getIntTempMap(level.getMapVertexId(parts.get(0).x - 1, parts.get(0).y) ) != GameLevel.TELEPORT )
				if( rndNumber-- == 0)
					return Snake.LEFT;
			if ( level.getIntTempMap(level.getMapVertexId(parts.get(0).x, parts.get(0).y + 1) ) < 0 && level.getIntTempMap(level.getMapVertexId(parts.get(0).x, parts.get(0).y + 1) ) != GameLevel.TELEPORT )
				if( rndNumber-- == 0)
					return Snake.DOWN;
			if ( level.getIntTempMap(level.getMapVertexId(parts.get(0).x, parts.get(0).y - 1) ) < 0 && level.getIntTempMap(level.getMapVertexId(parts.get(0).x, parts.get(0).y - 1) ) != GameLevel.TELEPORT )
				if( rndNumber-- == 0)
					return Snake.UP;
		}
		return direction;
	}
	
	public int getDirection( int nextVert )
	{
	}
	
	public void bfs()
	{
		int neightboor;
		int neightboorId;
		int current;
		int currentParent;
		
		clearQueque();
		pushQueque(getSnakeTarget(),-1);
		
		/* Отдельно обработаем соседей клеток соседних с целевой, т.к. на них
		 * влияет финиширует ли змейка или нет. Т.к. если бы целевая точка - 
		 * это финишная точка, то соседей в обычной жизни у нее нет, т.к. чаще
		 * всего она - стена.
		 */
		current = popQueque();
		neightboorId = 0;
		
		while( ( neightboor = level.getMapGraphNeighbours(current, neightboorId++) ) > -1 )
		{
			
		}
/*		
		while( ( neightboor = level.getMapGraphNeighbours(current, neightboorId++) ) > -1 )
		{
			edgeWeight = level.getMapGraphWeight(current, neightboor); 
			if( edgeWeight != -1 && vertexWayWeight[vertexPosition[neightboor]] > vertexWayWeight[vertexPosition[current]] + edgeWeight )
			{
				newkey = vertexWayWeight[vertexPosition[current]] + edgeWeight;
				vertex = neightboor;
				heapPosition = vertexPosition[vertex];
				
				if(!( newkey > vertexWayWeight[heapPosition] ))
				{
									
					vertexWayWeight[heapPosition] = newkey;
					
					while ((heapPosition > 0) && (vertexWayWeight[heapPosition/2] > vertexWayWeight[heapPosition] ))
					{
						tmp2 = vertexWayWeight[heapPosition];
						vertexWayWeight[heapPosition] = vertexWayWeight[heapPosition/2];
						vertexWayWeight[heapPosition/2] = tmp2;
							
						tmp2 = vertexPosition[vertexInvPosition[heapPosition]];
						vertexPosition[vertexInvPosition[heapPosition]] = vertexPosition[vertexInvPosition[heapPosition/2]];
						vertexPosition[vertexInvPosition[heapPosition/2]] = tmp2;
						
						tmp2 = vertexInvPosition[heapPosition];
						vertexInvPosition[heapPosition] = vertexInvPosition[heapPosition/2];
						vertexInvPosition[heapPosition/2] = tmp2;
								
						heapPosition = heapPosition/2;
					}
				}
				
				vertexPreviousPath[neightboor] = current;
			}
		}
		
		while(! isEmptyQueque() )
		{
			current = popQueque();			
			while( ( neightboor = level.getMapGraphNeighbours(current, neightboorId++) ) > -1 )
			{
				edgeWeight = level.getMapGraphWeight(current, neightboor); 
				if( edgeWeight != -1 && vertexWayWeight[vertexPosition[neightboor]] > vertexWayWeight[vertexPosition[current]] + edgeWeight )
				{
					newkey = vertexWayWeight[vertexPosition[current]] + edgeWeight;
					vertex = neightboor;
					heapPosition = vertexPosition[vertex];
					
					if(!( newkey > vertexWayWeight[heapPosition] ))
					{
										
						vertexWayWeight[heapPosition] = newkey;
						
						while ((heapPosition > 0) && (vertexWayWeight[heapPosition/2] > vertexWayWeight[heapPosition] ))
						{
							tmp2 = vertexWayWeight[heapPosition];
							vertexWayWeight[heapPosition] = vertexWayWeight[heapPosition/2];
							vertexWayWeight[heapPosition/2] = tmp2;
								
							tmp2 = vertexPosition[vertexInvPosition[heapPosition]];
							vertexPosition[vertexInvPosition[heapPosition]] = vertexPosition[vertexInvPosition[heapPosition/2]];
							vertexPosition[vertexInvPosition[heapPosition/2]] = tmp2;
							
							tmp2 = vertexInvPosition[heapPosition];
							vertexInvPosition[heapPosition] = vertexInvPosition[heapPosition/2];
							vertexInvPosition[heapPosition/2] = tmp2;
									
							heapPosition = heapPosition/2;
						}
					}
					
					vertexPreviousPath[neightboor] = current;
				}
			}
		}*/
	}
	
	public void nextTurn()
	{
		//if( parts.size() > finishSize)
//			deykstraFinish();
//		else
//			deykstra();
//		direction = chooseDirection();
	}
}
